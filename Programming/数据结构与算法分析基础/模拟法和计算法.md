模拟法（simulate algorithm）和计算法（count algorithm）是两类常用的算法。
模拟法对问题的运行过程进行模拟，同步跟踪问题状态，并最终得到问题的答案。计算法通过研究问题的运行逻辑，试图找到一种能够从问题的初始状态计算得到问题答案的计算算法。
模拟法和计算法有各自的优缺点和使用环境，两者都是不可替代的。本文从一道简单的Codeforces题目开始，讲解并比较这两种算法。

## 一  问题引入

从一道Codeforces题目开始：1987C  Basil's Garden

> There are $n$ flowers in a row, the $i$-th of them initially has a positive height of $h_i$ meters.
>Every second, the wind will blow from the left, causing the height of some flowers to decrease.
> Specifically, every second, for each $i$ from $1$ to $n$, in this order, the following happens:
>
> - If $i=n$ or $h_i>h_i+1$, the value of $h_i$ changes to $max(0,h_i−1)$.
>
> How many seconds will pass before $h_i=0$ for all $1≤i≤n$ for the first time?

#### 1  模拟法解决问题

这个问题可以用模拟法简单地解决。

用一个数组`arr`模拟排成一列的$n$朵花。由于我们只关心花的高度，所以每朵花可以用一个`int`类型的变量模拟。于是，`arr[ i ]`模拟第$i$朵花，表示第$i$朵花的高度。
用一个`int`类型的变量`time`模拟计时器。计时器被初始化为$0$，每过一秒，计时器递增$1$。

对问题的运行过程的模拟是简单的。用一个`while`循环来模拟，每当一阵风吹过，`while`循环就循环一次。每次循环中，从前向后遍历数组`arr`，对每一朵花，判断它是否被吹低一段；如果是，则将花的高度递减$1$；如果否，则什么都不做。检查条件是简单的：$i=n$ or $h_i>h_i+1$，题目中已经给出。每次循环结束之前，还需要递增计时器，并判断是否所有的花都被吹倒，如果是则退出循环。

这一算法的思考和实现也非常简单。问题的运行过程、算法的运行过程、算法的实际编码都是一致的，不需要过多的思考。于是，可以非常简单地如下所示对模拟法编码。

```java
int dieCount = 0;
int time = 0;
while( dieCount < arr.length ) {
	for( int i=0; i < arr.length - 1 - dieCount; i++ )
		if( arr[ i ] > arr[ i+1 ] )
			arr[ i ]--;
    
	if( arr[ arr.length - 1 - dieCount ] > 0 )
		arr[ arr.length - 1 - dieCount ]--;
	if( arr[ arr.length - 1 - dieCount ] == 0 )
	dieCount++;
    
	time++;
}

return time;
```

在这段代码中，对原算法作了一点小小的改动，用一个变量`dieCount`记录被吹倒的花的数目，并将`dieCount < arr.length`作为是否退出循环的判断条件。这一改动能略微优化算法的运行时间，不过对算法的时间复杂度并无影响。

该算法的思考和编码是非常简单的，熟练的程序员应该能在五分钟内完成。
可是，对于该算法的分析指出，该算法的时间复杂度是$O( N * sum( M ) )$，其中$N$是花的数量而$M$是花的高度。对算法的进一步分析指出，$sum( M )$可以被优化到$max( M) + N$，但算法的时间复杂度最多被优化到$O( N * ( M + N ) )$，不可以再被优化了。这意味着该算法的时间复杂度是平方级的，是不可接受的；当算法的输入数据非常大时，算法会遇到明显的瓶颈。

模拟法的问题在哪里？事实上，模拟法的算法没有任何问题，但是问题的运行过程本身就需要非常多的步骤和时间。在这一过程之下应该隐藏着某种规律，可是模拟法只关心问题的运行过程，而不关心问题的运行逻辑。为了发现问题的运行逻辑以优化算法，需要使用计算法。

#### 2  计算法解决问题

分析这个问题会发现，每一朵花被吹倒的时间，与它之后的一朵花的高度和被吹倒的时间都有关系，但和它之前的花没有关系；如果这一朵花是最后一朵花，那么它在每一阵风吹过时都会被吹短一段，被吹倒的时间等于它的高度。
因此，我们用$h_i$和$time_i$表示第$i$朵花的高度和被吹倒的时间，并研究$h_{i-1}$，$h_i$，$time_{i-1}$，$time_i$之间的关系。$h_{i-1}$和$h_i$是确定的，而$time_{n-1}$被初始化为$h_{n-1}$。因此，$time_{i-1}$应该能从另外三者推出。我们还将不加区分地用$h_i$表示第$i$朵花和第$i$朵花的高度。

考虑一种简单的情况：如果$h_{i-1}$在每次被风吹过时，$h_i$都小于$h_{i-1}$，那么$h_{i-1}$每次都会被风吹短一段。在这种情况下，应该有$time_{i-1} = h_{i-1}$。
可是情况不总是那么简单。如果$h_{i-1}$在被吹断之前，发生过$h_{i-1} = h_i$的情况，那么$h_{i-1}$被吹短的过程就要受制于$h_i$被吹短的过程了。仔细分析会发现，在这种情况下，$h_{i-1}$被吹短的过程一定精确地慢一步，因此有$time_{i-1} = time_i + 1$。

现在来考虑每一朵花应该属于哪一种情况了。
如果初始时有$h_{i-1} <= h_i$，那么一定属于第二种情况。
如果初始时为$h_{i-1} > h_i$，这种情况非常复杂。因为$h_i$被吹短的过程中，有可能在某个高度保持不变一段时间，保持高度的次数、时间和时机都是很复杂的；如果再考虑$h_{i-1}$就更加复杂了。我们接下来仔细分析这种情况。

如果$h_{i-1} <= time_i$，那么这一定属于第二种情况。为什么？可以这样思考。如果属于第一种情况，$h_{i-1}$被连续地吹短，那么有$time_{i-1} = h_{i-1} <= time_i$。最终，$h_{i-1}$先于$h_i$被吹断；可是这是不可能的，因此假设错误，应该属于第二种情况。我们得到$time_{i-1} = time_i + 1$。
如果$h_{i-1} > time_i$，那么无法确定属于第一种情况还是第二种情况。可是我们可以换一种思路考虑，无论属于哪种情况，都一定有$time_{i-1} >= h_{i-1} >= time_{i} + 1$。于是，在这种情况下，可以表示为$time_{i-1} = max( h_{i-1}, time_i + 1 )$。

其它情况能否这样表示呢？换言之，$h_{i-1} <= h_i$时，或$h_{i-1} > h_i$且$h_{i-1} <= time_i$时，能否表示为$time_{i-1} = max( h_{i-1}, time_i + 1 )$呢？幸运的是可以的，于是我们得到最终的递推公式：$time_{i-1} = max( h_{i-1}, time_i + 1 )$。

最终，通过计算法，我们发现了递推公式$time_{i-1} = max( h_{i-1}, time_i + 1 )$。使用该递推公式计算每一朵花被吹倒的时间，最终的结果是所有吹倒时间的最大值。由于第一朵花被吹倒得最慢，因此只要取第一朵花的被吹倒的时间$time_0$即可。思考的过程是困难的，但编码是简单的。

```java
int[] times = new int[ arr.length ];
times[ arr.length - 1 ] = arr[ arr.length - 1 ];
for( int i = arr.length - 2; i >= 0; i-- )
	times [ i ] = Math.max( arr[ i ], times[ i+1 ] + 1 );

return times[ 0 ];
```

该算法的思考是非常困难的，甚至可能无法推导出该算法。可是算法的编码过程是非常简单的，只要推导出递推公式，编码很快就能完成。算法分析指出，时间复杂度是$O( N) $，这不可能产生任何改进了，因为肯定要对所有输入数据扫描一次；该算法对于合理规模的输入都能够在理想的时间内得到结果。我们看到，付出的努力都是值得的，我们得到了一个最优算法。

## 二  模拟法和计算法

通过这个问题，能够看到模拟法和计算法是怎样工作的。

模拟法适用于按照某个确定的过程推进并产生最终结果的问题。模拟法通过模拟这个过程，同步跟踪问题状态，并最终得到问题的答案。模拟法的思考和编码通常是很简单的，但大多数情况下会消耗大量的计算资源，有时还会消耗大量的内存资源，从而使模拟法在大规模数据输入的情况下成为不可运行的。模拟法的问题在于，它仅仅关注问题的运行过程，而不关心问题的运行逻辑，许多计算资源在琐碎繁杂的运行过程中消耗掉了。

计算法几乎适用于所有的问题。无论问题是否有明确的运行过程，计算法都研究问题的内部逻辑，试图找到一种算法，能够从问题的初始状态计算得到问题的答案。大多数优秀的算法都是计算法，例如动态规划和贪心算法等。计算法的思考是相当困难的，甚至可能会消耗程序员大量的时间和精力而无法推导出一种确定的算法。推导出计算法的算法之后，编码有可能很简单也有可能很困难，不过优秀的计算算法都能以可行的计算资源道得到问题答案。

计算法是否一定优于模拟法呢？不一定。如果只关心计算资源，即算法的时间复杂度，那么答案几乎一定是肯定的；对于同一个问题的计算法几乎肯定比模拟法更快，消耗更少的计算资源。可是考察一个算法的优劣是多方面的。如果输入数据的规模确定很少，那么就没有必要思考复杂的计算法；如果可以肯定模拟法已经很接近最优算法，那么直接实现模拟法即可。

计算法是否能解决所有的问题呢？也不一定。有的问题只能用模拟法解决而无法用计算法解决，有的问题只能用计算法解决而无法用模拟法解决，这都是无法肯定的。不过，如果将模拟法也视为特殊的计算法，即最简单粗暴的计算法，那么计算法确实能解决所有的问题；毕竟可以声称算法就是用计算来解决问题的。

总而言之，模拟法和计算法是设计算法的两种不同思路。两种算法互有优劣，不能相互替代，有的时候还要相互补充。
下表对比了模拟法和计算法，比较项目表示普遍情况而非所有情况。例如，模拟法的运行时间也可能很短。

|          |        模拟法        |        计算法        |
| :------: | :------------------: | :------------------: |
| 适用问题 | 有明确运行过程的问题 |     几乎所有问题     |
| 适用层次 |    比较简单的问题    | 很多优秀算法是计算法 |
| 思考时间 |          短          |          长          |
| 编码时间 |          短          |        不确定        |
| 运行时间 |          长          |          短          |
| 输入规模 |          小          |          大          |

