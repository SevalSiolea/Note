## 一  知识结构

#### 1  递归

1.1  定义递归
1.2  调用递归
1.3  错误使用递归
1.4  使用递归例子
1.5  递归准则

#### 2  相对增长率

2.1  相对增长率的概念
2.2  相对增长率的计算

#### 3  算法分析前提

3.1  计算模型
3.2  分析目标
3.3  示例问题

#### 4  分析运行时间

4.1  时间单元法
4.2  大O分析法
	4.2.1  分析递归

#### 5  分析最大子序列和问题

5.1  两个暴力算法
5.2  分治算法
5.3  线性算法
	5.3.1  联机算法

#### 6  对数运行时间

6.1  折半查找
6.2  辗转相除法
6.3  快速幂算法

## 二  主要内容

​	递归是本书学习的第一个重要算法。递归函数是调用自身的函数，其调用过程和普通函数并无区别。本章展示了几个错误使用递归和正确使用递归的例子，帮助学习者更好地理解递归。递归看似简单，但优秀地使用并不容易；需要遵守递归准则：基准情况、不断推进、设计法则、合成效益法则。

​	相对增长率是算法分析的数学基础。相对增长率在微积分中定义，用于比较函数的增长速度。在算法分析中一般不需要用到微积分，只需要用到几条计算准则和一些一致结论就可以进行简单的计算。
​	算法分析还需要一些前提。需要一个理想的计算模型，算法分析就在其中进行。算法分析的目标是分析最坏运行时间和平均运行时间，默认情况下分析前者。本章将以最大子序列和问题作为示例问题进行算法分析，这是因为这个问题有许多不同优劣的算法。

​	算法分析有两种基本方法：时间单元法和大O分析法。时间单元法逐行分析代码，深入分析细节，得到精确的运行时间单元。在大多数情况下时间单元法太过复杂，并且只关心大O结果，于是可以使用大O分析法。大O分析法给出了一系列分析准则，使分析只需要关注那些可能会成为时间瓶颈的代码段，并最终给出大O的近似结果。
​	对最大子序列和问题的分析使我们看到算法分析是如何进行的。该问题给出了四个算法：两个暴力算法、一个分治算法、一个线性算法，其中第二个暴力算法是在第一个暴力算法的基础上改进得到的。对该问题的分析还使我们看到了优秀算法的价值和算法分析的价值。

​	最后讨论一类特殊的算法，其运行时间含有对数。当算法能划分为不同部分并分别求解时，算法的运行时间中就会有对数；因此分治算法的运行时间常常含有对数。本章给出了三个典型算法：折半查找、辗转相除法和快速幂算法。

## 三  重点梳理

- 掌握递归，理解递归准则，掌握如何优秀地使用递归。
- 掌握算法分析，掌握时间单元法和大O分析法，掌握如何使用大O分析法分析递归。
- 理解最大子序列和问题，理解分析该问题的意义。
- 掌握对数运行时间，掌握三个典型算法：折半查找、辗转相除法、快速幂算法。

## 四  难点解析

#### 1  什么是递归？如何使用递归？递归准则如何指导更好地使用递归？

​	递归从数学定义衍生而来。在数学中，递归是调用自己的函数。算法中的递归与之类似，一个方法如果在方法体中包含它自己的方法调用，则称这个方法是递归的。

​	递归方法需要包含两个部分：基准情况和递归调用。递归方法必须存在某种基准情况，不需要另一次递归调用即可执行本次递归调用并返回。当不属于基准情况时，递归方法必须向某种基准情况推进，并最终推进到这种基准情况的递归调用作为终点。务必小心递归方法不能推进到终点的错误递归使用。
​	递归调用就像普通方法调用一样。首次递归调用时，会产生一个方法调用栈，只是栈中的方法都是相同的方法。作为终点的递归调用不再调用该递归方法，像普通方法调用一样，执行方法并返回。每个递归调用执行并返回，直到首次递归调用向调用者返回结果。

​	递归准则包括以下四条准则：
​	1  基准情况。必须存在某种基准情况，不需要另一次递归调用即可执行并返回。
​	2  不断推进。不属于基准情况时，连续的递归调用必须向某种基准情况推进。
​	3  设计法则。假设所有的递归调用都能正确运行。
​	4  合成效益法则。不要在不同的递归调用中执行相同的递归调用。
​	前两条递归准则指导递归方法设计的基本原则，在之前已经分析过。接下来分析后两条递归准则。

​	设计法则指导我们，设计递归方法时，假设其他递归调用都能正确运行，把目光关注于当前递归调用中，从而能够像设计普通方法一样设计递归方法。
​	考虑一种简单的情况，需要设计一个递归方法$f(n)$，并且将会以不同的参数$n$执行不同的递归调用。首先考虑基准情况下的递归调用，此时的递归方法设计是简单的，就像设计普通方法一样。接下来考虑某个非基准情况的递归调用$f(n_1)$，它需要执行另一个递归调用$f(n_2)$，或者还可能有其它的递归调用。设计法则指导我们，假设所有的递归调用都能正确运行。于是，我们不需要考虑$f(n_2)$应该如何设计或者如何执行；我们只需要假设$f(n_2)$能够正确运行并返回结果，可以像使用变量一样使用$f(n_2)$的返回结果，只需要考虑$f(n_1)$如何使用$f(n_2)$得出结果即可。设计法则使得我们可以像设计普通方法一样设计递归方法，不必关注连续递归调用的复杂细节，只需要考虑当前递归调用即可。

​	合成效益法则指导我们避免设计糟糕的递归方法。动态规划本质上是充分利用合成效益法则的递归算法。
​	考虑斐波那契数列的递归方法$f(n)$，它在方法体中调用$f(n-1)$和$f(n-2)$，并以$f(0)$和$f(1)$作为基准情况。这个递归方法的设计是相当简单的，但它的运行效率却相当糟糕。其原因在于，$f(n-1)$在方法体中又调用$f(n-2)$。当$f(n-1)$返回后，$f(n)$不会记得$f(n-2)$的返回值，于是重新执行$f(n-2)$。于是$f(n-2)$被重复执行了两次，这就造成了浪费。进一步分析，$f(n-3)$会被重复执行三次，$f(n-4)$会被重复执行五次，以此类推。已经执行的方法调用被抛弃，而在某处又重新执行，重复的递归调用递归地合并起来，造成了惊人的浪费。精确的数学分析指出，递归调用数目是以指数形式增长的，因此该递归方法的时间复杂度是指数级的。在$n$很小时执行递归方法就已经成为了不可能。
​	违背合成效益法则的递归方法不仅是降低方法效率那么简单。当递归深度很浅时，递归调用就需要惊人的时间，很容易因为内存限制而引发异常。因此，这样的递归方法是失败的，是根本不可用的。不要违背合成效益法则，就像不要违背其他三条递归法则一样。

#### 2  如何计算相对增长率？

​	相对增长率是数学中的概念，用于衡量两个函数$f(n)$和$g(n)$增长的相对速率。
​	假设$f(n)$和$g(n)$均恒正且单调不减，$n$为正整数，则：
​	1  $f(n)=O(g(n))$：$f(n)$慢于或等于$g(n)$。
​	2  $f(n)=\Omega(g(n))$：$f(n)$快于或等于$g(n)$。
​	3  $f(n)=\Theta(g(n))$：$f(n)$等于$g(n)$。
​	4  $f(n)=o(g(n))$：$f(n)$慢于$g(n)$。注意与$f(n)=O(g(n))$区分，不包括增长率相等的情况。

​	可以用微积分的知识求解相对增长率。求解$\lim\limits_{n \to +\infty} \frac{ f(n) }{ g(n) }$的极限：
​	1  极限为0：$f(n)$慢于$g(n)$。
​	2  极限为正无穷：$f(n)$快于$g(n)$。
​	3  极限为非零常数：$f(n)$等于$g(n)$。
​	其他情况在算法分析中基本上是不可能出现的，可以不考虑。

​	不过，在算法分析中，往往不需要微积分来求解相对增长率。事实上，由于$f(n)$和$g(n)$的形式通常并不复杂，相对增长率的求解只需要简单的代数方法即可。利用本章的几个重要结论和典型函数的相对增长率即可求解。
​	例如，$f(n)=nlogn$和$g(n)=n^{1.5}$求解相对增长率。由于我们关注相对性，从而可以约去$n$，比较$logn$和$n^{0.5}$。给两边平方，这实际上就是比较$log^2n$和$n$。由于任意次幂的对数慢于线性的相对增长率，于是前者增长较慢。于是，得到最终结论，$f(n)$慢于$g(n)$。

​	相对增长率是算法分析的重要概念。通常，$n$表示输入量，例如某个数组的长度或者关键循环的次数；而$f(n)$和$g(n)$分别表示两个算法在输入量$n$下的资源消耗。通过比较相对增长率，就可以比较两个算法在输入量$n$较大时的资源消耗趋势。因此，在算法分析中，希望相对增长率越低越好。

#### 3  算法分析的计算模型是怎样的？分析目标是什么？

​	算法分析需要在一个计算模型中进行。这个计算模型是理想计算模型，但它适用于大部分实际情况。
​	1  该计算模型是一个标准的冯诺依曼结构计算机，并有一个标准的简单指令系统。
​	2  该计算模型执行任何一条简单指令都只需要一个时间单元。四则运算、移位、赋值等指令均包括在内，尽管加法运算和除法运算事实上运行时间相差很大。诸如数组排序或矩阵求逆的操作显然不是简单指令。另外方法分析也不是简单指令。
​	3  该计算模型有无限的内存，不需要考虑缺页中断和磁盘访问等问题，所有的数据都在内存中。这一特点有时不适用实际的情况，此时需要特殊的算法分析；不过，大多数情况还是适用的。

​	算法分析的目的是算法的资源消耗，即时间资源和空间资源。
​	在大多数情况下更关注算法的时间资源。计算机硬件的发展使得空间资源更加廉价，而高性能和高实时性的要求使得时间资源更为紧张。此外，大多数情况下，糟糕的算法并不会消耗过多的空间资源，但可能会消耗过多的时间资源，除非遇到糟糕的递归方法等特殊情况。
​	分析算法的时间资源时，给定输入量$n$，算法消耗的时间资源可用$f(n)$表示。$f(n)$如何计算稍后讲解。虽然还有其他因素的影响，但输入量是最主要也是最容易分析的因素。此外，可能有多个输入量参数。

​	分析算法的时间资源时，通常关注平均情况的时间资源$f_{avg}(n)$和最坏情况的时间资源$f_{worst}(n)$。$f_{avg}(n)$能反映典型的时间资源，在算法被随机重复执行时非常有用；$f_{worst}(n)$则对最坏情况作出保证，使得算法在任何情况下都不至于失控。偶尔也分析最好情况的时间资源，不过大多数情况都没有什么意义。
​	通常情况下都分析最坏情况的时间资源$f_{worst}(n)$，这是因为平均情况的时间资源$f_{avg}(n)$是非常难以计算的，甚至平均的标准为何都难以定义。例如，可以是所有输入情况的算术平均，实际输入情况的加权平均，或者是不同方法调用情况的平均。

​	另外，还要指出，算法分析只针对于算法而不针对语言或程序。给定一个算法，可以用不同的编程语言实现该算法，即使是同样的语言也可以编写出细节不同的程序。通常而言不同的实现只会有不同的细微差距，而算法分析的指导意义依然存在。

​	算法分析在输入量很大的情况下是一个很有意义的工作。如果预计算法的输入量很小，在任何输入情况下都能得到让人满意的结果，那么就没有必要进行算法分析了，除非算法确实极其糟糕。在这种情况下，尝试实现算法并进行一些简单的测试，也许是更好的选择。

#### 4  为什么要学习算法分析？算法分析的意义是什么？

#### 5  如何进行算法分析？分别讲解时间单元法和大O分析法。

#### 6  对最大子序列和问题的分析有什么意义？

#### 7  算法运行时间中为何会出现对数？对数运行时间的规律是什么？

## 五  重要图表

- P6  错误使用递归
  ![错误使用递归](D:\Learn\Note\Programming\数据结构与算法分析基础\Image\1 算法分析基础\错误使用递归.png)
- **P21  典型的相对增长率**
  ![典型的相对增长率](D:\Learn\Note\Programming\数据结构与算法分析基础\Image\1 算法分析基础\典型的相对增长率.png)
- P26 & P27  最大子序列和问题的两个暴力算法
  ![最大子序列和问题的暴力算法_1](D:\Learn\Note\Programming\数据结构与算法分析基础\Image\1 算法分析基础\最大子序列和问题的暴力算法_1.png)
  ![最大子序列和问题的暴力算法_2](D:\Learn\Note\Programming\数据结构与算法分析基础\Image\1 算法分析基础\最大子序列和问题的暴力算法_2.png)
- **P29  最大子序列和问题的分治算法**
  ![最大子序列和问题的分治算法](D:\Learn\Note\Programming\数据结构与算法分析基础\Image\1 算法分析基础\最大子序列和问题的分治算法.png)
- **P30  最大子序列和问题的线性算法**
  ![最大子序列和问题的线性算法](D:\Learn\Note\Programming\数据结构与算法分析基础\Image\1 算法分析基础\最大子序列和问题的线性算法.png)
- P31  折半查找算法
  ![折半查找算法](D:\Learn\Note\Programming\数据结构与算法分析基础\Image\1 算法分析基础\折半查找算法.png)
- P32  辗转相除法
  ![辗转相除法](D:\Learn\Note\Programming\数据结构与算法分析基础\Image\1 算法分析基础\辗转相除法.png)
- P33  快速幂算法
  ![快速幂算法](D:\Learn\Note\Programming\数据结构与算法分析基础\Image\1 算法分析基础\快速幂算法.png)

## 六  薄弱点清单



------

